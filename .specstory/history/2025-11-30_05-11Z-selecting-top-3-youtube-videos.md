<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 7edcffaf-822d-4a83-bc97-ed6bfaad1509 (2025-11-30 05:11Z) -->

# Selecting top 3 youtube videos (2025-11-30 05:11Z)

_**User (2025-12-01 18:01Z)**_

show me where we are selecting the top 3 videos from youtube using their description and title

---

_**Agent (model gemini-3-pro-preview, mode Ask)**_

<think><details><summary>Thought Process</summary>
**Beginning the Search for Code**

I've initiated the keyword search, focusing on terms like "youtube," "video," "top 3," "description," and "title." The goal is to pinpoint the exact code segment responsible for selecting the top three YouTube videos based on their titles and descriptions. I'm sifting through the results now.


**Locating Scoring Mechanisms**

I'm now zeroing in on the potential scoring and filtering mechanisms. The keyword search unveiled several promising code snippets. My approach is to identify where "description" and "title" are processed together, indicating a scoring function. I'm focusing on the logic that ranks or prioritizes videos.


</details></think>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "where are we selecting top 3 youtube videos using description and title" • **8** results</summary>
            
| File | Lines |
|------|-------|
| `src/app/actions.ts` | L538-869 |
| `src/app/actions.ts` | L519-869 |
| `src/app/actions.ts` | L83-265 |
| `amazon_scraper/selectors.yml` | L42 |
| `src/app/admin/actions.ts` | L71-184 |
| `src/types.ts` | L89-111 |
| `supabase/migrations/20251127000000_rag_schema.sql` | L34-75 |
| `src/app/admin/inventory/actions.ts` | L309-405 |

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Identifying Relevant Code**

I've located the likely code snippet within `src/app/actions.ts`. Lines 593-622 feature the `filterVideosWithLLM` function. I see it accepts a video list and formats them. I'm now digging into its operations to understand the logic.


**Deep Diving into the Function**

I've examined the `filterVideosWithLLM` function's internal workings more closely. It crafts a prompt for the LLM, feeding it formatted video data. This prompt asks the LLM to pick the top three videos based on a skill and user-defined disaster scenarios. I am reviewing the prompt generation logic to assess its effectiveness.


**Examining Prompt Construction**

I'm focusing now on the prompt construction. The function formats video data into a string, incorporating titles and descriptions. This string is then incorporated into a larger prompt for the LLM. My next step involves scrutinizing the prompt itself, specifically how it guides the LLM selection process.


**Confirming Code's Relevance**

I've confirmed the `filterVideosWithLLM` function indeed fulfills the user's request. It incorporates video titles and descriptions within its prompt to the LLM. Line 597 formats the video data, and line 604 directs the LLM to select the top videos. I'm satisfied this addresses the query.


</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/app/actions.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Reviewing the Implementation**

I'm currently focused on the `filterVideosWithLLM` function. I've pinpointed its location in `src/app/actions.ts` and am now diving into the specifics. I'm noting the initial mapping process, where titles and descriptions are formatted for the LLM input, specifically lines 597-599.


**Assessing Prompt Construction**

I'm now zeroing in on the prompt creation within the `filterVideosWithLLM` function. I'm taking a close look at how the `videoListText` is incorporated. Lines 601-619 define the prompt that requests the LLM to select the top videos, a direct response to the user's prompt, and which includes the list of videos. This seems solid, I'll move on.


</details></think>

---

The code that selects the top 3 YouTube videos based on their description and title is located in `src/app/actions.ts`.

Specifically, the `filterVideosWithLLM` function handles this logic:

1.  It formats a list of videos into a string that includes their `Title`, `Channel`, and `Description` (lines 597-599).
2.  It sends this list to the LLM (Gemini) with a prompt explicitly asking to "Select the top 3 most valuable YouTube videos" based on the provided criteria (lines 601-619).

Here is the relevant code block:

```typescript:src/app/actions.ts
// ... existing code ...
    // Helper to filter videos using LLM
    const filterVideosWithLLM = async (videos: any[], skill: string, scenarios: string[]): Promise<{ selectedVideos: any[], reasoning?: string }> => {
        if (videos.length === 0) return { selectedVideos: [] };

        const model = "gemini-2.5-flash";
        const videoListText = videos.map((v, i) => 
            `ID: ${v.id}\nTitle: ${v.title}\nChannel: ${v.channel}\nDescription: ${v.description}\n---`
        ).join('\n');

        const prompt = `
        You are an expert survival instructor curating the best educational content.
        
        Task: Select the top 3 most valuable YouTube videos from the list below for learning the skill: "${skill}".
        Context: The user is preparing for these disaster scenarios: ${scenarios.join(', ')}.
        
        CRITERIA:
        1. MUST be an instructional "How-to" or tutorial video.
        2. STRICTLY EXCLUDE: News reports, "caught on camera" footage, reaction videos, vlogs without substance, or generic "top 10" lists unless highly educational.
        3. FOCUS: Practical, actionable skills (e.g., "How to fix a flat tire" vs "Coin acceptor repair").
        4. RELEVANCE: Must be directly related to "${skill}" in a survival context.
        
        Videos to Evaluate:
        ${videoListText}
        
        Return a JSON object with:
        - "selectedIds": Array of video IDs for the top 3 videos.
        - "reasoning": Brief explanation of why these were chosen.
        `;
// ... existing code ...
```

---

